---
title: "1. Introduction to Model Context Protocol"
date: "2025-06-25 22:44:36 +0900"
last_modified_at: "2025-06-25 22:44:36 +0900"
---

[Welcome to the 🤗 Model Context Protocol (MCP) Course - Hugging Face MCP Course](https://huggingface.co/learn/mcp-course/unit0/introduction)

## 0. Welcome to the 🤗 Model Context Protocol (MCP) Course

1.  **🤗 Model Context Protocol (MCP)コースの紹介:** このコースは、AIにおける最新のトピックであるMCPを、初心者から熟知したレベルまで理解し、利用し、応用するための無料コースです。Anthropicとの提携により構築され、コースの概要、認定プロセス、スケジュール、チームの紹介、アカウント作成、Discordサーバーへの参加などを通じて、学習を開始するための準備をします。

2.  **コースの内容と目標:** このコースでは、MCPの理論、設計、実践を学び、確立されたMCP SDKやフレームワークの使用方法を習得し、自身のプロジェクトを共有し、コミュニティが作成したアプリケーションを探求し、MCPの実装を評価するチャレンジに参加し、課題を完了することで修了証明書を取得できます。コース修了時には、MCPの仕組みと、最新のMCP標準を使用して外部データやツールを活用した独自のAIアプリケーションを構築する方法を理解することを目標としています。

3.  **コースの構成:** コースは、MCPの概念を理論的に学ぶ「基礎ユニット」、確立されたMCP SDKを使用してアプリケーションを構築する「ハンズオン」、学習した概念を実際の課題に適用する「ユースケース課題」、そしてHugging Faceのパートナーとの連携による最新のMCP実装とツールを提供する「コラボレーション」で構成されています。このコースは、受講者のフィードバックと貢献によって進化する生きたプロジェクトです。

4.  **シラバスの概要:** コースのシラバスは、導入（ツールの設定）、MCPの基礎、アーキテクチャ、コアコンセプトの説明、MCPを活用したシンプルなユースケースの紹介、エンドツーエンドのMCPアプリケーションの構築、Hugging Faceエコシステムとパートナーのサービスを使用したMCPアプリケーションのデプロイ、パートナーのライブラリとサービスを活用するためのボーナスユニットで構成されています。

5.  **受講に必要な前提知識:** このコースを受講するには、AIとLLMの基本的な理解、ソフトウェア開発の原則とAPIの概念に対する理解、少なくとも1つのプログラミング言語の経験（PythonまたはTypeScriptの例が示されます）が必要です。これらの知識がない場合でも、LLMやエージェントに関するコースを受講することで補完できますが、必須ではありません。

6.  **必要なツール:** コースを受講するために必要なものは、インターネット接続のあるコンピュータと、コースのリソースにアクセスし、プロジェクトを作成するためのアカウントのみです。アカウントは無料で作成できます。

7.  **認定プロセス:** コースは監査モードで受講するか、アクティビティに参加して2種類の証明書のいずれかを取得するかを選択できます。監査モードで受講する場合は、チャレンジへの参加や課題の実施は任意です。認定プロセスは完全に無料であり、基礎証明書はユニット1の完了で、修了証明書はユースケースユニット（2と3）の完了で取得できます。

8.  **推奨されるペース:** 各チャプターは1週間で完了するように設計されており、週あたり約3〜4時間の作業が必要です。推奨されるペースに従って進めることができます。

9.  **コースから最大限に得るためのアドバイス:** Discordで学習グループに参加し、クイズや課題に取り組み、スケジュールを立てて同期を保つことが、コースから最大限に得るための鍵となります。

10. **コース作成者と協力者:** コースの作成者は、Hugging FaceのMachine Learning EngineerであるBen Burtenshawと、AnthropicのTechnical Partner Enablement LeadであるAlex Notovです。また、Gradio、Continue、Llama.cpp、Anthropicなどの個人やパートナーからの貢献とサポートに感謝の意を表しています。バグの報告やコースの改善提案は歓迎されます。質問はDiscordサーバーで受け付けています。

## 1. Introduction to Model Context Protocol

1.  **モデルコンテキストプロトコル (MCP) の概要と重要性：** この講座の最初のユニットでは、モデルコンテキストプロトコル（MCP）の基礎を学びます。MCPは、AIエコシステムが急速に進化する中で、大規模言語モデル（LLM）などのAIシステムが持つ、学習データやリアルタイム情報へのアクセスの制限を克服するために重要です。MCPは、AIモデルと外部データソース、ツール、環境を接続し、AIシステムとより広いデジタル世界の間で情報をシームレスに転送することを可能にします。

2.  **MCPで解決する課題：** MCPは、特に「M×N統合問題」と呼ばれる課題の解決を目指しています。これは、多数のモデルと多数のツールやデータソースを統合する際に発生する複雑さを指します。MCPは、標準化されたプロトコルを提供することで、これらの統合を簡素化し、AIアプリケーションの開発と展開を促進します。

3.  **MCPの主要な概念と用語：** このユニットでは、MCPに関連する基本的な概念と用語を学びます。これらを理解することで、MCPのアーキテクチャと実装をより深く理解するための基盤を築きます。

4.  **MCPの利点と目標：** MCPは、標準化、AI機能の強化、相互運用性という主要な利点を提供します。これにより、AIモデルはより関連性が高く、正確で、役立つ応答を提供できるようになります。MCPの目標は、AIアプリケーションの開発を加速し、AIシステムの実用性を高めることです。

5.  **MCP統合の簡単な例：** 講座の最後に、MCP統合の簡単な例を通して、MCPが実際にどのように機能するかを理解します。これにより、MCPの基本的な概念を実践的に理解し、今後のユニットでより複雑なアプリケーションを探求するための準備を整えます。

6.  **MCPコースの構成：** コースは、MCPの概要から始まり、実際のユースケース、カスタムワークフローサーバーの開発へと進みます。具体的には、GitHub上のプルリクエストエージェントの構築のような応用例も含まれます。


### Key Concepts and Terminology
1.  **モデルコンテキストプロトコル (MCP) の概要と目的:** MCPは、AIモデルを外部の機能と連携させるための標準化されたプロトコルであり、「AIアプリケーションのためのUSB-C」と例えられます。これにより、様々なAIアプリケーション、ツール、データソース間の相互運用性が向上し、開発者はよりシンプルで一貫性のある体験をユーザーに提供できるようになります。MCPは、AIエコシステム全体のイノベーションを促進し、分断化を軽減することを目指しています。

#### The Integration Problem
2.  **M×N統合問題とその解決:** MCPがない場合、M個のAIアプリケーションとN個の外部ツール/データソースを連携させるには、M×N個のカスタム統合が必要となり、複雑性とコストが増大します。MCPはこの問題を、各AIアプリケーションがMCPクライアントを、各ツール/データソースがMCPサーバーを一度実装するだけで済むM+Nの問題に変換します。これにより、統合の複雑さが大幅に軽減され、メンテナンスの負担も軽減されます。

##### Without MCP (M×N Problem)
##### With MCP (M+N Solution)"
#### Core MCP Terminology
##### Components
3.  **MCPの主要な構成要素（コンポーネント）:** MCPは、HTTPと同様にクライアント・サーバーモデルを採用しています。**ホスト**は、ユーザーが直接対話するAIアプリケーション（例：Claude Desktop、AI強化されたIDE、推論ライブラリ）であり、MCPサーバーへの接続を開始し、ユーザーリクエスト、LLM処理、外部ツール間のフローを調整します。**クライアント**は、ホストアプリケーション内のコンポーネントであり、特定のMCPサーバーとの通信を管理します。**サーバー**は、MCPプロトコルを介して機能（ツール、リソース、プロンプト）を公開する外部プログラムまたはサービスです。

##### Capabilities
4.  **MCPの主要な機能（ケイパビリティ）:** MCPによって提供される価値は、アプリケーションが提供する機能の総和です。**ツール**は、AIモデルがアクションを実行したり、計算されたデータを取得するために呼び出すことができる実行可能な関数です。**リソース**は、重要な計算なしにコンテキストを提供する読み取り専用データソースです。**プロンプト**は、ユーザー、AIモデル、利用可能な機能間のインタラクションを導く事前定義されたテンプレートまたはワークフローです。**サンプリング**は、クライアント/ホストにLLMインタラクションを実行させるサーバー主導のリクエストであり、LLMが生成されたコンテンツをレビューし、さらなる決定を下すことができる再帰的なアクションを可能にします。

5.  **コードエージェントのユースケースにおけるMCPの機能:** コードエージェントの例を通して、MCPの各機能がどのように使用されるか説明されています。**コードインタープリター**はLLMが書いたコードを実行するツール、**ドキュメンテーション**はアプリケーションのドキュメントを含むリソース、**コードスタイル**はLLMがコードを生成する際のプロンプト、**コードレビュー**はLLMがコードをレビューし決定を行うサンプリングとして利用されます。これらの要素を組み合わせることで、コードエージェントは効率的にコードを生成・改善できます。

##### Conclusion

### Architectural Components of MCP
#### Host, Client, and Server
1.  **MCPのアーキテクチャは、ホスト、クライアント、サーバーの3つの主要コンポーネントで構成されています。** ホストはユーザーが直接対話するAIアプリケーション（ChatGPTなど）であり、クライアントはホスト内のコンポーネントで、特定のMCPサーバーとの通信を管理します。サーバーは、MCPプロトコルを介してAIモデルに機能を提供する外部プログラムまたはサービスです。

##### Host
2.  **ホストの主な役割は、ユーザーとのインタラクションの管理、MCPサーバーへの接続の開始、ユーザーリクエスト、LLM処理、外部ツール間の全体的なフローの調整、そして結果をユーザーにわかりやすい形式で表示することです。** 例えば、開発者はCursor、専門家はsmolagents上に構築されたカスタムアプリケーションを選択するなど、ユーザーはニーズに応じてホストアプリケーションを選択します。

##### Client
3.  **クライアントは、ホストのロジックと外部サーバーの間の仲介役として機能し、サーバーとの1対1の接続を維持し、MCP通信のプロトコルレベルの詳細を処理します。** クライアントは、ホストがどのサーバーに接続するかを指示し、サーバーが提供する機能を問い合わせます。

##### Server
4.  **サーバーは、特定の外部ツール、データソース、またはサービスへのアクセスを提供し、既存の機能の軽量なラッパーとして機能します。** サーバーはローカルまたはリモートで実行でき、クライアントが発見して使用できる標準化された形式でその機能を提供します。

#### Communication Flow
#### Conclusion
5.  **MCPのアーキテクチャはモジュール性が高く、1つのホストが異なるクライアントを介して複数のサーバーに同時に接続できます。** これにより、従来のM×Nの統合問題を、より管理しやすいM+Nの問題に変換し、各ホストとサーバーがMCP標準を1回実装するだけで済むようになります。このアーキテクチャは、AIモデルが外部ツールやデータソースとシームレスに接続できる連携エコシステムを可能にします。


### The Communication Protocol
1.  MCP（Message Communication Protocol）は、クライアントとサーバー間の一貫性があり、予測可能なメッセージ交換を可能にする標準化された通信プロトコルです。この標準化は、コミュニティ全体の相互運用性にとって非常に重要です。MCPはJSON-RPC 2.0を基盤としており、軽量なリモートプロシージャコールプロトコルとして機能します。JSON形式なので、人間が読みやすくデバッグが容易であり、言語に依存しないため、あらゆるプログラミング環境で実装できます。また、明確な仕様と広範な採用実績があります。

#### JSON-RPC: The Foundation
2.  MCPプロトコルは、リクエスト、レスポンス、通知の3種類のメッセージを定義しています。リクエストはクライアントからサーバーへ操作の開始を指示し、レスポンスはリクエストに対するサーバーからの応答（成功またはエラー）を伝え、通知はサーバーからクライアントへの一方向メッセージで、応答を必要とせずにイベントの更新や通知を提供します。各メッセージにはJSON-RPC 2.0の形式に従った構造が定義されており、一意のID、メソッド名、パラメータなどが含まれます。

##### 1. Requests
##### 2. Responses
##### 3. Notifications
#### Transport Mechanisms
3.  MCPはJSON-RPCメッセージの伝送メカニズムとして、stdio（標準入出力）とHTTP + SSE（Server-Sent Events）/ストリーム可能なHTTPの2つをサポートしています。stdioはクライアントとサーバーが同じマシン上で動作する場合にローカル通信に使用され、HTTP+SSEはクライアントとサーバーが異なるマシン上にある場合のリモート通信に使用されます。stdioはシンプルでネットワーク設定が不要であり、HTTP+SSEはネットワークを跨いで動作し、ウェブサービスとの連携を可能にします。ストリーム可能なHTTPはサーバーレス環境との互換性を維持しつつ、必要に応じてSSEに動的にアップグレードできる柔軟性を提供します。

##### stdio (Standard Input/Output)
##### HTTP + SSE (Server-Sent Events) / Streamable HTTP
#### The Interaction Lifecycle
4.  MCPプロトコルにおけるクライアントとサーバー間の完全なインタラクションライフサイクルは、初期化、ディスカバリー、実行、および終了の4つの段階で構成されます。初期化段階では、クライアントとサーバーがプロトコルバージョンと能力を交換します。ディスカバリー段階では、クライアントが利用可能な能力に関する情報を要求し、サーバーが利用可能なツールの一覧を応答します。実行段階では、クライアントがホストのニーズに基づいて能力を呼び出し、終了段階では、接続が不要になったときに正常に閉じられ、サーバーがシャットダウン要求を認識します。

##### Initialization
##### Discovery
##### Execution
##### Termination
#### Protocol Evolution
5.  MCPプロトコルは拡張可能で適応可能なように設計されています。初期化フェーズにはバージョンネゴシエーションが含まれており、プロトコルが進展するにつれて下位互換性を確保します。さらに、能力ディスカバリーにより、クライアントは各サーバーが提供する特定の機能に適応できるため、同じエコシステム内で基本的なサーバーと高度なサーバーを混在させることができます。

### Understanding MCP Capabilities
### MCP（モデル・コントロール・プロトコル）の機能に関する概要
#### Tools
1.  **ツール（Tools）:** AIモデル（LLM）によって制御され、クライアントからサーバーへの方向にアクションやAPI呼び出し、データ操作を実行する実行可能な関数またはアクションです。実行には副作用を伴う可能性があるため、通常はユーザーの明示的な承認が必要です。具体的な使用例としては、メッセージの送信、チケットの発行、APIへのクエリ、計算の実行などが挙げられます。例えば、特定の場所の現在の気象データを取得する天気ツールなどがあります。

#### Resources
2.  **リソース（Resources）:** アプリケーションによって制御され、クライアントからサーバーへの方向に読み取り専用のデータソースへのアクセスを提供する機能です。複雑なロジックを実行することなくコンテキストを取得できます。REST APIのGETエンドポイントと同様に、最小限の計算でデータを取得するように設計されています。読み取り専用であるため、ツールよりもセキュリティリスクは通常低くなります。具体的な使用例としては、ファイルコンテンツへのアクセス、データベースレコードの取得、構成情報の読み取りなどがあります。

#### Prompts
3.  **プロンプト（Prompts）:** ユーザーによって制御され、サーバーからクライアントへの方向に、ユーザー、AIモデル、およびサーバーの機能間のインタラクションをガイドする定義済みのテンプレートまたはワークフローです。利用可能なツールとリソースを最適に使用するための構造化されたインタラクションを提供します。ユーザーは通常、AIモデルが処理を開始する前にプロンプトを選択し、インタラクションのコンテキストを設定します。一般的なワークフロー、特殊なタスクテンプレート、ガイド付きインタラクションなどに使用されます。

#### Sampling
4.  **サンプリング（Sampling）:** サーバーによって制御され、サーバーからクライアント、そしてクライアントからサーバーへの方向に、クライアント（特にホストアプリケーション）にLLMインタラクションの実行を要求することを可能にする機能です。サーバー駆動のエージェント的な動作や、潜在的に再帰的または多段階のインタラクションを可能にします。ツールと同様に、サンプリング操作には通常、ユーザーの承認が必要です。複雑な多段階タスク、自律的なエージェントワークフロー、インタラクティブなプロセスなどに使用されます。サンプリングフローには、サーバーがクライアントにサンプリング/createMessageリクエストを送信し、クライアントがリクエストを確認して変更し、LLMからサンプリングを行い、完了内容を確認し、結果をサーバーに返すという手順が含まれます。

#### How Capabilities Work Together
5.  **各機能の連携:** これらの機能は、相補的な方法で連携するように設計されています。ユーザーは特殊なワークフローを開始するためにプロンプトを選択し、プロンプトにはリソースからのコンテキストが含まれる場合があります。処理中に、AIモデルはツールを呼び出して特定のアクションを実行する可能性があります。複雑な操作の場合、サーバーはサンプリングを使用して追加のLLM処理を要求する場合があります。

#### Discovery Process
6.  **機能の動的な発見（Discovery Process）:** MCPの主要な機能の1つは、動的な機能の発見です。クライアントがサーバーに接続すると、特定のリストメソッド（`tools/list`、`resources/list`、`prompts/list`）を介して、利用可能なツール、リソース、およびプロンプトをクエリできます。この動的な発見メカニズムにより、クライアントはサーバーの機能をハードコードされた知識なしに、各サーバーが提供する特定の機能に適応できます。

#### Conclusion

## MCP SDK
### SDK Overview
1.  **MCP SDKの概要と機能:** Model Context Protocol (MCP) は、JavaScript、Pythonなどの言語向けの公式SDKを提供し、アプリケーションでのMCPクライアントおよびサーバーの実装を容易にします。これらのSDKは、プロトコルの詳細を処理し、開発者がアプリケーションの機能構築に集中できるようにします。SDKは、プロトコルレベルの通信、機能の登録と発見、メッセージのシリアライズ/デシリアライズ、接続管理、エラー処理などの基本的な機能を備えています。

### Core Primitives Implementation
2.  **MCPの主要な要素（ツール、リソース、プロンプト）の実装:** SDKを利用して、MCPの中核となる要素、つまりツール、リソース、プロンプトを実装する方法が示されています。Pythonの例では、`@mcp.tool()` デコレータを使って `get_weather` ツールを定義し、`@mcp.resource()` で `weather_resource` を定義し、`@mcp.prompt()` で `weather_report` を定義しています。これらの例は、MCPサーバーでこれらの要素をどのように作成し、使用するかを示しています。

3.  **MCPサーバーの起動とMCP Inspector:** サーバーを実装した後、サーバーのスクリプトを実行してサーバーを起動できます。これにより、開発サーバーが初期化され、MCP Inspectorが起動します。MCP Inspectorは、`http://127.0.0.1:6274` でアクセスでき、サーバーの機能を確認し、UIを通じてそれらとやり取りすることができます。

### MCP SDKs
4.  **MCP SDKの利用可能な言語:** MCPは言語に依存しないように設計されており、TypeScript、Python、Java、Kotlin、C#、Swift、Rust、Dart/Flutterなど、さまざまなプログラミング言語で利用可能な公式SDKがあります。これらのSDKは、MCPプロトコルの操作を簡素化するための言語固有の抽象化を提供し、開発者が低レベルのプロトコルの詳細ではなく、サーバーまたはクライアントの中核となるロジックの実装に集中できるようにします。 GitHubリポジトリとメンテナーが示されており、アクティブなSDKの状態も記載されています。

### Next Steps
5.  **次のステップとLLMとの連携:** このテキストでは、MCPの基本的なサーバーを実行する方法を説明していますが、これは始まりにすぎません。次のステップとして、LLM (大規模言語モデル) からサーバーに接続する方法が示唆されています。これにより、MCPを利用して、LLMとバックエンドサービスを連携させることが可能になります。

---

## MCP Clients
MCP（Model Context Protocol）クライアントは、AIアプリケーション（ホスト）とMCPサーバーが提供する外部機能との間の橋渡し役として機能します。クライアントには、チャットインターフェースクライアントやインタラクティブ開発クライアントなどの種類があり、設定ファイル（mcp.json）を通じてMCPサーバーとの接続を管理します。

### Understanding MCP Clients
MCPクライアントは、ホスト内のMCP通信を処理する専用モジュールとして機能し、ユーザーからの入力をMCPサーバーに送信し、サーバーからの応答をユーザーに提示する役割を担います。これにより、AIアプリケーションはファイルシステムの操作、Webの閲覧、コードの実行といった外部の能力を活用できます。

### User Interface Client
ユーザーがMCPサーバーと対話するためのフロントエンドとして機能するクライアントで、主にチャットインターフェースクライアントとインタラクティブ開発クライアントの2つのタイプがあります。

#### Chat Interface Clients
ユーザーが自然言語でAIエージェントと対話できるチャットベースのインターフェースです。Hugging Faceは、GradioをベースにしたオープンソースのチャットUIクライアントを提供しています。

#### Interactive Development Clients
開発者がMCPサーバーを操作し、デバッグするためのツールで、JupyterノートブックやIDEの拡張機能などが含まれ、サーバーの機能を直接テストしたり、リクエストやレスポンスを確認したりするのに役立ちます。主要な実装例として、AnthropicのClaude Desktop、CursorのMCPクライアント実装、Continue.devなどがあります。

### Configuring MCP Clients
MCPクライアントがMCPサーバーと通信するための設定方法について説明します。設定は通常mcp.jsonという名前のJSONファイルで行われ、接続するサーバーのリストと通信方法を定義します。

#### MCP Configuration Files
MCPクライアントの設定ファイルは、クライアントが接続するサーバーのリストを定義し、各サーバーには名前とトランスポート（通信方法）タイプが指定されます。

##### mcp.json Structure
基本的な構造は以下の通りです：

```json
{
  "servers": [
    {
      "name": "サーバー名",
      "transport": {
        "type": "stdio|sse"
      }
    }
  ]
}
```

##### Configuration for stdio Transport
ローカルで実行されるサーバーでstdioトランスポートを使用する場合、設定にはサーバープロセスを起動するためのコマンドと引数が含まれます：

```json
{
  "servers": [
    {
      "name": "ファイルエクスプローラー",
      "transport": {
        "type": "stdio",
        "command": "python",
        "args": ["/path/to/file_explorer_server.py"]
      }
    }
  ]
}
```

##### Configuration for HTTP+SSE Transport
リモートサーバーでHTTP+SSEトランスポートを使用する場合、設定にはサーバーのURLが含まれます：

```json
{
  "servers": [
    {
      "name": "リモートAPIサーバー",
      "transport": {
        "type": "sse",
        "url": "https://example.com/mcp-server"
      }
    }
  ]
}
```

##### Environment Variables in Configuration
APIキーのような機密情報を安全に渡すために、`env` フィールドを使ってサーバープロセスに環境変数を設定できます：

```json
{
  "servers": [
    {
      "name": "GitHub API",
      "transport": {
        "type": "stdio",
        "command": "python",
        "args": ["/path/to/github_server.py"],
        "env": {
          "GITHUB_TOKEN": "your_github_token"
        }
      }
    }
  ]
}
```

Pythonで環境変数にアクセスするには、`os`モジュールを使用します：

```python
import os

github_token = os.environ.get("GITHUB_TOKEN")
if not github_token:
  raise ValueError("GITHUB_TOKEN environment variable is required")

def make_github_request():
  headers = {"Authorization": f"Bearer {github_token}"}
```

#### Configuration Examples
実際の使用例を通じて、異なるシナリオでの設定方法を説明します。

##### Scenario 1: Local Server Configuration
ローカルサーバーの設定例として、ファイルエクスプローラーサーバーをstdioトランスポートで設定する方法を示します。

```python
{
  "servers": [
    {
      "name": "File Explorer",
      "transport": {
        "type": "stdio",
        "command": "python",
        "args": ["/path/to/file_explorer_server.py"] // This is an example, we'll use a real server in the next unit
      }
    }
  ]
}
```

##### Scenario 2: Remote Server Configuration
リモートサーバーの設定例として、HTTP+SSEトランスポートを使用したAPIサーバーの設定方法を示します。

```python
{
  "servers": [
    {
      "name": "Weather API",
      "transport": {
        "type": "sse",
        "url": "https://example.com/mcp-server" // This is an example, we'll use a real server in the next unit
      }
    }
  ]
}
```
### Tiny Agents Clients
`tiny-agents` は、コードから直接MCPサーバーに接続するためのクライアントとして機能するシンプルなAIエージェントです。コマンドライン環境でMCPサーバーを実行でき、MCPサーバーからのツールを使用できるAIエージェントを簡単に作成する方法を提供します。

#### Setup
セットアップには以下のステップが必要です：
1. `npx` をインストール (`npm install -g npx`)
2. MCPをサポートする `huggingface_hub` ライブラリをインストール (`pip install "huggingface_hub[mcp]>=0.32.0"`)
3. Hugging Face HubにログインしてMCPサーバーにアクセス (`huggingface-cli login`)

#### Connecting to MCP Servers
エージェント設定ファイル(`agent.json`)を作成し、使用するモデル、プロバイダー、そして接続するMCPサーバーの情報を記述します：

```json
{
    "model": "Qwen/Qwen2.5-72B-Instruct",
    "provider": "nebius",
    "servers": [
        {
            "type": "stdio",
            "config": {
                "command": "npx",
                "args": ["@playwright/mcp@latest"]
            }
        }
    ]
}
```

エージェントは、`tiny-agents run agent.json` コマンドで実行できます。

### Next Steps
MCPクライアントの基本的な理解と設定が完了したら、次は実際のMCPサーバーとの統合やより複雑な設定への進展を検討できます。
```

---

## Gradio MCP Integration
1.  GradioとMCPの統合により、機械学習モデル用のカスタマイズ可能なウェブインターフェースを迅速に作成できるGradioを使用して、MCPサーバーを簡単に作成できます。Gradioはデモやプロトタイプの作成、非技術的なユーザーとのモデル共有、モデルの挙動のテストとデバッグに特に役立ちます。MCPサポートの追加により、Gradioは標準化されたMCPプロトコルを通じてAIモデルの機能を公開する簡単な方法を提供します。
### Introduction to Gradio
### Prerequisites
2.  GradioでMCPサーバーを使用するには、`pip install "gradio[mcp]"`でGradioをインストールする必要があります。また、CursorのようなMCPプロトコルを使用したツール呼び出しをサポートするLLMアプリケーション（"MCPホスト"として知られる）も必要です。

### Creating an MCP Server with Gradio
3.  GradioでMCPサーバーを作成する基本的な例として、`letter_counter`関数を定義し、Gradioの`Interface`を使用して、テキストと文字を入力し、文字の出現回数をカウントするインターフェースを作成します。`demo.launch(mcp_server=True)`でMCPサーバーを有効にすると、関数はGradioのウェブインターフェースとMCPクライアントの両方からアクセス可能になります。

### How It Works Behind the Scenes
4.  `demo.launch(mcp_server=True)`を設定すると、Gradio関数は自動的にMCPツールに変換され、入力コンポーネントはツール引数のスキーマにマッピングされ、出力コンポーネントは応答形式を決定します。GradioサーバーはMCPプロトコルメッセージをリッスンし、JSON-RPC over HTTP+SSEがクライアントサーバー通信用に設定されます。
### Key Features of the Gradio <> MCP Integration
5.  GradioとMCPの統合の重要な機能は、Gradioアプリの各APIエンドポイントが、対応する名前、説明、入力スキーマを持つMCPツールに自動的に変換されることです。ツールとスキーマを表示するには、`http://your-server:port/gradio_api/mcp/schema`にアクセスするか、Gradioアプリのフッターにある「View API」リンクをクリックし、「MCP」をクリックします。

6.  MCPサーバー機能を有効にする方法は、`demo.launch(mcp_server=True)`を使用するか、環境変数`GRADIO_MCP_SERVER=True`を使用するかの2つがあります。
7.  サーバーは自動的にファイルデータ変換を処理し、Base64エンコードされた文字列をファイルデータに変換したり、画像ファイルを処理して正しい形式で返したり、一時ファイルストレージを管理します。入力画像やファイルは、完全なURL（"http://..."または"https://..."）として渡すことが強く推奨されます。

### Troubleshooting Tips
8.  GradioアプリケーションはHugging Face Spacesで無料で公開でき、無料のホスト型MCPサーバーを持つことができます。トラブルシューティングのヒントとして、型ヒントと有効なドキュメント文字列を提供すること、入力引数を`str`として受け入れ関数内で目的の型に変換すること、SSEをサポートしていないMCPホストの場合は`mcp-remote`を使用すること、接続の問題が発生した場合はMCPクライアントとMCPサーバーの両方を再起動することが挙げられます。

### Share your MCP Server
### Conclusion
9.  GradioとMCPの統合により、GradioのシンプルさとMCPの標準化を活用することで、開発者は最小限のコードで人間フレンドリーなインターフェースとAIアクセス可能なツールを迅速に作成できます。
