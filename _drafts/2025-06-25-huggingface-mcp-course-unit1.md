---
title: "1. Introduction to Model Context Protocol"
date: "2025-06-25 22:44:36 +0900"
last_modified_at: "2025-06-25 22:44:36 +0900"
---

[Welcome to the 🤗 Model Context Protocol (MCP) Course - Hugging Face MCP Course](https://huggingface.co/learn/mcp-course/unit0/introduction)

## 0. Welcome to the 🤗 Model Context Protocol (MCP) Course

1.  **🤗 Model Context Protocol (MCP)コースの紹介:** このコースは、AIにおける最新のトピックであるMCPを、初心者から熟知したレベルまで理解し、利用し、応用するための無料コースです。Anthropicとの提携により構築され、コースの概要、認定プロセス、スケジュール、チームの紹介、アカウント作成、Discordサーバーへの参加などを通じて、学習を開始するための準備をします。

2.  **コースの内容と目標:** このコースでは、MCPの理論、設計、実践を学び、確立されたMCP SDKやフレームワークの使用方法を習得し、自身のプロジェクトを共有し、コミュニティが作成したアプリケーションを探求し、MCPの実装を評価するチャレンジに参加し、課題を完了することで修了証明書を取得できます。コース修了時には、MCPの仕組みと、最新のMCP標準を使用して外部データやツールを活用した独自のAIアプリケーションを構築する方法を理解することを目標としています。

3.  **コースの構成:** コースは、MCPの概念を理論的に学ぶ「基礎ユニット」、確立されたMCP SDKを使用してアプリケーションを構築する「ハンズオン」、学習した概念を実際の課題に適用する「ユースケース課題」、そしてHugging Faceのパートナーとの連携による最新のMCP実装とツールを提供する「コラボレーション」で構成されています。このコースは、受講者のフィードバックと貢献によって進化する生きたプロジェクトです。

4.  **シラバスの概要:** コースのシラバスは、導入（ツールの設定）、MCPの基礎、アーキテクチャ、コアコンセプトの説明、MCPを活用したシンプルなユースケースの紹介、エンドツーエンドのMCPアプリケーションの構築、Hugging Faceエコシステムとパートナーのサービスを使用したMCPアプリケーションのデプロイ、パートナーのライブラリとサービスを活用するためのボーナスユニットで構成されています。

5.  **受講に必要な前提知識:** このコースを受講するには、AIとLLMの基本的な理解、ソフトウェア開発の原則とAPIの概念に対する理解、少なくとも1つのプログラミング言語の経験（PythonまたはTypeScriptの例が示されます）が必要です。これらの知識がない場合でも、LLMやエージェントに関するコースを受講することで補完できますが、必須ではありません。

6.  **必要なツール:** コースを受講するために必要なものは、インターネット接続のあるコンピュータと、コースのリソースにアクセスし、プロジェクトを作成するためのアカウントのみです。アカウントは無料で作成できます。

7.  **認定プロセス:** コースは監査モードで受講するか、アクティビティに参加して2種類の証明書のいずれかを取得するかを選択できます。監査モードで受講する場合は、チャレンジへの参加や課題の実施は任意です。認定プロセスは完全に無料であり、基礎証明書はユニット1の完了で、修了証明書はユースケースユニット（2と3）の完了で取得できます。

8.  **推奨されるペース:** 各チャプターは1週間で完了するように設計されており、週あたり約3〜4時間の作業が必要です。推奨されるペースに従って進めることができます。

9.  **コースから最大限に得るためのアドバイス:** Discordで学習グループに参加し、クイズや課題に取り組み、スケジュールを立てて同期を保つことが、コースから最大限に得るための鍵となります。

10. **コース作成者と協力者:** コースの作成者は、Hugging FaceのMachine Learning EngineerであるBen Burtenshawと、AnthropicのTechnical Partner Enablement LeadであるAlex Notovです。また、Gradio、Continue、Llama.cpp、Anthropicなどの個人やパートナーからの貢献とサポートに感謝の意を表しています。バグの報告やコースの改善提案は歓迎されます。質問はDiscordサーバーで受け付けています。

## 1. Introduction to Model Context Protocol

1.  **モデルコンテキストプロトコル (MCP) の概要と重要性：** この講座の最初のユニットでは、モデルコンテキストプロトコル（MCP）の基礎を学びます。MCPは、AIエコシステムが急速に進化する中で、大規模言語モデル（LLM）などのAIシステムが持つ、学習データやリアルタイム情報へのアクセスの制限を克服するために重要です。MCPは、AIモデルと外部データソース、ツール、環境を接続し、AIシステムとより広いデジタル世界の間で情報をシームレスに転送することを可能にします。

2.  **MCPで解決する課題：** MCPは、特に「M×N統合問題」と呼ばれる課題の解決を目指しています。これは、多数のモデルと多数のツールやデータソースを統合する際に発生する複雑さを指します。MCPは、標準化されたプロトコルを提供することで、これらの統合を簡素化し、AIアプリケーションの開発と展開を促進します。

3.  **MCPの主要な概念と用語：** このユニットでは、MCPに関連する基本的な概念と用語を学びます。これらを理解することで、MCPのアーキテクチャと実装をより深く理解するための基盤を築きます。

4.  **MCPの利点と目標：** MCPは、標準化、AI機能の強化、相互運用性という主要な利点を提供します。これにより、AIモデルはより関連性が高く、正確で、役立つ応答を提供できるようになります。MCPの目標は、AIアプリケーションの開発を加速し、AIシステムの実用性を高めることです。

5.  **MCP統合の簡単な例：** 講座の最後に、MCP統合の簡単な例を通して、MCPが実際にどのように機能するかを理解します。これにより、MCPの基本的な概念を実践的に理解し、今後のユニットでより複雑なアプリケーションを探求するための準備を整えます。

6.  **MCPコースの構成：** コースは、MCPの概要から始まり、実際のユースケース、カスタムワークフローサーバーの開発へと進みます。具体的には、GitHub上のプルリクエストエージェントの構築のような応用例も含まれます。


### Key Concepts and Terminology
1.  **モデルコンテキストプロトコル (MCP) の概要と目的:** MCPは、AIモデルを外部の機能と連携させるための標準化されたプロトコルであり、「AIアプリケーションのためのUSB-C」と例えられます。これにより、様々なAIアプリケーション、ツール、データソース間の相互運用性が向上し、開発者はよりシンプルで一貫性のある体験をユーザーに提供できるようになります。MCPは、AIエコシステム全体のイノベーションを促進し、分断化を軽減することを目指しています。

#### The Integration Problem
2.  **M×N統合問題とその解決:** MCPがない場合、M個のAIアプリケーションとN個の外部ツール/データソースを連携させるには、M×N個のカスタム統合が必要となり、複雑性とコストが増大します。MCPはこの問題を、各AIアプリケーションがMCPクライアントを、各ツール/データソースがMCPサーバーを一度実装するだけで済むM+Nの問題に変換します。これにより、統合の複雑さが大幅に軽減され、メンテナンスの負担も軽減されます。

##### Without MCP (M×N Problem)
##### With MCP (M+N Solution)"
#### Core MCP Terminology
##### Components
3.  **MCPの主要な構成要素（コンポーネント）:** MCPは、HTTPと同様にクライアント・サーバーモデルを採用しています。**ホスト**は、ユーザーが直接対話するAIアプリケーション（例：Claude Desktop、AI強化されたIDE、推論ライブラリ）であり、MCPサーバーへの接続を開始し、ユーザーリクエスト、LLM処理、外部ツール間のフローを調整します。**クライアント**は、ホストアプリケーション内のコンポーネントであり、特定のMCPサーバーとの通信を管理します。**サーバー**は、MCPプロトコルを介して機能（ツール、リソース、プロンプト）を公開する外部プログラムまたはサービスです。

##### Capabilities
4.  **MCPの主要な機能（ケイパビリティ）:** MCPによって提供される価値は、アプリケーションが提供する機能の総和です。**ツール**は、AIモデルがアクションを実行したり、計算されたデータを取得するために呼び出すことができる実行可能な関数です。**リソース**は、重要な計算なしにコンテキストを提供する読み取り専用データソースです。**プロンプト**は、ユーザー、AIモデル、利用可能な機能間のインタラクションを導く事前定義されたテンプレートまたはワークフローです。**サンプリング**は、クライアント/ホストにLLMインタラクションを実行させるサーバー主導のリクエストであり、LLMが生成されたコンテンツをレビューし、さらなる決定を下すことができる再帰的なアクションを可能にします。

5.  **コードエージェントのユースケースにおけるMCPの機能:** コードエージェントの例を通して、MCPの各機能がどのように使用されるか説明されています。**コードインタープリター**はLLMが書いたコードを実行するツール、**ドキュメンテーション**はアプリケーションのドキュメントを含むリソース、**コードスタイル**はLLMがコードを生成する際のプロンプト、**コードレビュー**はLLMがコードをレビューし決定を行うサンプリングとして利用されます。これらの要素を組み合わせることで、コードエージェントは効率的にコードを生成・改善できます。

##### Conclusion

### Architectural Components of MCP
#### Host, Client, and Server
1.  **MCPのアーキテクチャは、ホスト、クライアント、サーバーの3つの主要コンポーネントで構成されています。** ホストはユーザーが直接対話するAIアプリケーション（ChatGPTなど）であり、クライアントはホスト内のコンポーネントで、特定のMCPサーバーとの通信を管理します。サーバーは、MCPプロトコルを介してAIモデルに機能を提供する外部プログラムまたはサービスです。

##### Host
2.  **ホストの主な役割は、ユーザーとのインタラクションの管理、MCPサーバーへの接続の開始、ユーザーリクエスト、LLM処理、外部ツール間の全体的なフローの調整、そして結果をユーザーにわかりやすい形式で表示することです。** 例えば、開発者はCursor、専門家はsmolagents上に構築されたカスタムアプリケーションを選択するなど、ユーザーはニーズに応じてホストアプリケーションを選択します。

##### Client
3.  **クライアントは、ホストのロジックと外部サーバーの間の仲介役として機能し、サーバーとの1対1の接続を維持し、MCP通信のプロトコルレベルの詳細を処理します。** クライアントは、ホストがどのサーバーに接続するかを指示し、サーバーが提供する機能を問い合わせます。

##### Server
4.  **サーバーは、特定の外部ツール、データソース、またはサービスへのアクセスを提供し、既存の機能の軽量なラッパーとして機能します。** サーバーはローカルまたはリモートで実行でき、クライアントが発見して使用できる標準化された形式でその機能を提供します。

#### Communication Flow
#### Conclusion
5.  **MCPのアーキテクチャはモジュール性が高く、1つのホストが異なるクライアントを介して複数のサーバーに同時に接続できます。** これにより、従来のM×Nの統合問題を、より管理しやすいM+Nの問題に変換し、各ホストとサーバーがMCP標準を1回実装するだけで済むようになります。このアーキテクチャは、AIモデルが外部ツールやデータソースとシームレスに接続できる連携エコシステムを可能にします。


### The Communication Protocol
1.  MCP（Message Communication Protocol）は、クライアントとサーバー間の一貫性があり、予測可能なメッセージ交換を可能にする標準化された通信プロトコルです。この標準化は、コミュニティ全体の相互運用性にとって非常に重要です。MCPはJSON-RPC 2.0を基盤としており、軽量なリモートプロシージャコールプロトコルとして機能します。JSON形式なので、人間が読みやすくデバッグが容易であり、言語に依存しないため、あらゆるプログラミング環境で実装できます。また、明確な仕様と広範な採用実績があります。

#### JSON-RPC: The Foundation
2.  MCPプロトコルは、リクエスト、レスポンス、通知の3種類のメッセージを定義しています。リクエストはクライアントからサーバーへ操作の開始を指示し、レスポンスはリクエストに対するサーバーからの応答（成功またはエラー）を伝え、通知はサーバーからクライアントへの一方向メッセージで、応答を必要とせずにイベントの更新や通知を提供します。各メッセージにはJSON-RPC 2.0の形式に従った構造が定義されており、一意のID、メソッド名、パラメータなどが含まれます。

##### 1. Requests
##### 2. Responses
##### 3. Notifications
#### Transport Mechanisms
3.  MCPはJSON-RPCメッセージの伝送メカニズムとして、stdio（標準入出力）とHTTP + SSE（Server-Sent Events）/ストリーム可能なHTTPの2つをサポートしています。stdioはクライアントとサーバーが同じマシン上で動作する場合にローカル通信に使用され、HTTP+SSEはクライアントとサーバーが異なるマシン上にある場合のリモート通信に使用されます。stdioはシンプルでネットワーク設定が不要であり、HTTP+SSEはネットワークを跨いで動作し、ウェブサービスとの連携を可能にします。ストリーム可能なHTTPはサーバーレス環境との互換性を維持しつつ、必要に応じてSSEに動的にアップグレードできる柔軟性を提供します。

##### stdio (Standard Input/Output)
##### HTTP + SSE (Server-Sent Events) / Streamable HTTP
#### The Interaction Lifecycle
4.  MCPプロトコルにおけるクライアントとサーバー間の完全なインタラクションライフサイクルは、初期化、ディスカバリー、実行、および終了の4つの段階で構成されます。初期化段階では、クライアントとサーバーがプロトコルバージョンと能力を交換します。ディスカバリー段階では、クライアントが利用可能な能力に関する情報を要求し、サーバーが利用可能なツールの一覧を応答します。実行段階では、クライアントがホストのニーズに基づいて能力を呼び出し、終了段階では、接続が不要になったときに正常に閉じられ、サーバーがシャットダウン要求を認識します。

##### Initialization
##### Discovery
##### Execution
##### Termination
#### Protocol Evolution
5.  MCPプロトコルは拡張可能で適応可能なように設計されています。初期化フェーズにはバージョンネゴシエーションが含まれており、プロトコルが進展するにつれて下位互換性を確保します。さらに、能力ディスカバリーにより、クライアントは各サーバーが提供する特定の機能に適応できるため、同じエコシステム内で基本的なサーバーと高度なサーバーを混在させることができます。



